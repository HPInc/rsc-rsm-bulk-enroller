# Copyright 2024 HP Development Company, L.P.
# SPDX-License-Identifier: MIT
'''RSC class'''
import enum
import logging
from typing import Dict, NoReturn, Tuple, Union
import requests

BASE_URL = "https://%s/redfish/v1/"
LOGIN_ENDPOINT = BASE_URL + "SessionService/Sessions"
SESSION_ENDPOINT = LOGIN_ENDPOINT + "/%s"
ACCOUNT_ENDPOINT = BASE_URL + "AccountService/Accounts/1"
MANAGER_ENDPOINT = BASE_URL + "Managers/1"
BIND_TO_CLOUD_ENDPOINT = MANAGER_ENDPOINT + "/Oem/HP/Actions/HP.BindToCloud"
TOKEN_HEADER_NAME = 'X-Auth-Token'
CHANGE_PROXY_NTP_ENDPOINT = BASE_URL + 'Managers/1/NetworkProtocol'


class TaskState(enum.Enum):
    '''Used to report the state of a long running redfish task'''
    SUCCESS = 0
    IN_PROGRESS = 1
    ERROR = 2
    CANCELLED = 3
    UNKNOWN = 4
    ALREADY_ENROLLED = 5

class RSCException(Exception):
    '''Exceptions generated by RSC operations'''

class RSC:
    '''Remote System Controller (RSC) class.'''
    # pylint: disable=too-many-instance-attributes
    def __init__(self, address: str, old_password: str, new_password: str) -> None:
        self.address = address
        self.old_password = old_password
        self.current_password = old_password
        self.new_password = new_password
        self.user_code = ""
        self.bind_monitor = ""
        self.monitor_state = TaskState.UNKNOWN
        self.session_id = ""
        self.session = None

    def __del__(self):
        if self.session_id:
            try:
                self.logout()
            except (requests.HTTPError, RSCException):
                logging.error("Failed to logout from %s", self.address)

    def __str__(self) -> str:
        return f"Addr: {self.address}\n\
            old pass: {self.old_password}\n\
            new password: {self.new_password}\n\
            current password: {self.current_password}"

    def login(self) -> None:
        '''logs in to the RSC and sets its session token if successful'''
        if self.session:
            self.logout()
        login_response: requests.Response = None
        try:
            login_response = requests.post(
                url=LOGIN_ENDPOINT % self.address,
                json={"UserName": "admin", "Password": self.current_password},
                timeout=10,
                verify=False)
            login_response.raise_for_status()

            self.session_id = login_response.json()['Id']
            self.session = requests.Session()
            self.session.headers.update(
                {TOKEN_HEADER_NAME: login_response.headers[TOKEN_HEADER_NAME]})
            self.session.verify = False
            self.session.timeout = 10

        except (requests.HTTPError , requests.JSONDecodeError,
                ConnectionRefusedError, requests.exceptions.ConnectionError) as ex:
            logging.debug("login failed with exception: %s", ex)
            self.raise_rsc_error(login_response, "Failed login on RSC  %s: %s")

    def logout(self) -> None:
        '''Logs out of the session'''
        req = requests.Request('DELETE', SESSION_ENDPOINT % (self.address, self.session_id))
        self.do_req_handle_exceptions(req, "logout")
        self.session = None

    def check_needs_change_password(self) -> bool:
        '''Checks if the password needs to be changed (is still the default password) '''
        # pylint: disable=inconsistent-return-statements
        # pylint seems to not understand that raise_rsc_error() raises an exception,
        # even though the function return type hint is 'NoReturn'.

        operation = "check if password needs change"

        req = requests.Request('GET', ACCOUNT_ENDPOINT % self.address)
        json_body, _ = self.do_req_get_body(req, operation)
        return json_body["PasswordChangeRequired"]

    def change_password(self) -> None:
        '''Creates a new session and changes password for this RSC.
        Sets the current password if successful.'''
        self.login()
        req = requests.Request('PATCH',
            ACCOUNT_ENDPOINT % self.address,
            json={"Password": self.new_password})
        self.do_req_handle_exceptions(req, "change password")

    def enroll_to_cloud(self) -> None:
        '''Invokes enroll to cloud to given RSC and records the task monitor
        for the operation and user code'''
        if self.is_enrolled_to_cloud():
            return
        req = requests.Request('POST', BIND_TO_CLOUD_ENDPOINT % self.address)
        body, response = self.do_req_get_body(req, "enroll to cloud")
        self.bind_monitor = response.headers["Location"]
        self.user_code = body["User_code"]
        self.monitor_state = TaskState.IN_PROGRESS

    def is_enrolled_to_cloud(self) -> bool:
        '''Checks if the RSC is already enrolled to cloud'''

        operation = "is enrolled to cloud"

        req = requests.Request('GET', MANAGER_ENDPOINT % self.address)
        json_body, _ = self.do_req_get_body(req, operation)
        status = json_body["Oem"]['HP']['HPRemoteSystemManagerBindingStatus']['BindingStatus']

        is_enrolled = status == 'Enrolled'

        if is_enrolled:
            self.monitor_state = TaskState.ALREADY_ENROLLED

        return is_enrolled

    def get_bind_status(self) -> TaskState:
        '''Updates and returns the task state for the monitor of cloud enrollment for this RSC'''
        # pylint seems to not understand that raise_rsc_error() raises an exception,
        # even though the function return type hint is 'NoReturn'.

        # pylint: disable=inconsistent-return-statements
        if not self.bind_monitor:
            raise RSCException("RSC not in the process of enrollment to cloud")

        req = requests.Request('GET', f"https://{self.address}{self.bind_monitor}")
        json_body, response = self.do_req_get_body(req, "get enrollment status")
        logging.debug("get_bind_status RSC '%s' code: %d response: %s",
                          self.address, response.status_code, json_body)

        if response.status_code == 202:
            self.monitor_state = TaskState.IN_PROGRESS
        elif response.status_code in [200, 201]:
            self.monitor_state = TaskState.SUCCESS
        else:
            self.monitor_state = TaskState.ERROR

        return self.monitor_state

    def set_proxy_ntp_settings(self, proxy_address: str, ntp_server: str) -> None:
        '''Sets NTP and proxy settings to this RSC'''
        ntp_settings = {
            "NTPServers": [
                ntp_server
            ],
            "ProtocolEnabled": True
        }

        proxy_settings = {
            "Enabled": len(proxy_address) > 0,
            "ProxyServerURI": proxy_address,
        }

        settings = {}
        if len(proxy_address) > 0:
            settings['Proxy'] = proxy_settings
        if len(ntp_server) > 0:
            settings['NTP'] = ntp_settings

        if settings:
            req = requests.Request('PATCH', CHANGE_PROXY_NTP_ENDPOINT % self.address, json=settings)
            self.do_req_handle_exceptions(req, "set proxy/NTP settings")

    def raise_rsc_error(self, response: requests.Response, error_fmt: str) -> NoReturn:
        '''Takes in a response and a format error message and raises an RSCException.
        error_fmt has to have placeholders for two strings: the RSC address and the error
        message for the response'''
        error = get_message_from_response(response)
        raise RSCException(error_fmt % (self.address, error))

    def cancel_enrollment(self) -> None:
        '''Cancels the enrollment process for this RSC'''
        req = requests.Request('DELETE', f"https://{self.address}{self.bind_monitor}")
        self.do_req_handle_exceptions(req, "cancel enrollment")

    def do_req_handle_exceptions(self, req: requests.Request, operation: str) -> requests.Response:
        '''Performs a request and handles exceptions'''
        try:
            response = self.session.send(self.session.prepare_request(req))
            logging.debug("do_req_handle_exceptions RSC '%s' code: %d ok: %s response: %s",
                          self.address, response.status_code, response.ok, response.text)
            if response is not None and not response.ok:
                logging.debug("response was not ok")
                self.raise_rsc_error(response, f"Operation '{operation}' failed on RSC %s: %s")
            return response
        except requests.exceptions.ConnectionError as ex:
            raise RSCException(f"Failed to connect to RSC {self.address}: {ex}") from ex
        except ConnectionRefusedError as ex:
            raise RSCException(f"Connection refused by RSC {self.address}: {ex}") from ex
        except requests.HTTPError as ex:
            logging.debug("exception: %s", ex)
            raise RSCException(f"Operation '{operation}' failed on RSC {self.address}") from ex

    def get_body(self, response: requests.Response, operation: str) -> Dict:
        '''Gets the body of the response and handles exceptions'''
        try:
            return response.json()
        except requests.JSONDecodeError as ex:
            raise RSCException(
                f"Failed to parse response from RSC {self.address} during {operation}") from ex

    def do_req_get_body(self, req: requests.Request,
                        operation: str) -> Tuple[Dict, requests.Response]:
        '''Performs a request and returns the body of the response and the response'''
        response = self.do_req_handle_exceptions(req, operation)
        return self.get_body(response, operation), response

def get_message_from_response(response: requests.Response) -> Union[str, None]:
    '''Extracts the message from a response error'''
    if response is None:
        return None
    logging.debug("Reponse code: %d", response.status_code)
    if response.status_code < 200 or response.status_code >= 300:
        try:
            error: dict = response.json().get('error')
            if error is None:
                return None
            extended_message_info = error.get('@Message.ExtendedInfo')
            if extended_message_info:
                message_info = extended_message_info[0]['Message']
                if ('Oem' in extended_message_info[0] and
                        'HP' in extended_message_info[0]['Oem'] and
                        'ErrorDetails' in extended_message_info[0]['Oem']['HP']):
                    details = extended_message_info[0]['Oem']['HP'].get('ErrorDetails')
                    if len(details) > 0:
                        message_info += ("\nDetails: '" + details + "'")
                return message_info
        except requests.JSONDecodeError:
            logging.debug("can't get message from response.")
            return "can't get message from response."

    return None
